name: Deploy to Production

on:
  push:
    branches: [chore/dependency-cleanup]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_FRONTEND_REPO: ${{ secrets.ECR_FRONTEND_REPO }}
  ECR_BACKEND_REPO: ${{ secrets.ECR_BACKEND_REPO }}
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
  ECS_FRONTEND_SERVICE: ${{ secrets.ECS_FRONTEND_SERVICE }}
  ECS_BACKEND_SERVICE: ${{ secrets.ECS_BACKEND_SERVICE }}
  CLOUDWATCH_FRONTEND_LOG_GROUP: /ecs/${{ secrets.ECR_FRONTEND_REPO }}
  CLOUDWATCH_BACKEND_LOG_GROUP: /ecs/${{ secrets.ECR_BACKEND_REPO }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Collect code changes
        id: git-diff
        run: |
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            git diff HEAD~1 HEAD > /tmp/code_changes.diff
            echo "has_diff=true" >> $GITHUB_OUTPUT
          else
            echo "No previous commit" > /tmp/code_changes.diff
            echo "has_diff=false" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build and push Frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build --target production \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest \
            --push ./front

      - name: Build and push Backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest \
            --push ./back

      # ìºì‹œ ê°±ì‹  (ì˜¤ë˜ëœ ìºì‹œ ì‚­ì œ í›„ ìƒˆ ìºì‹œ ì´ë™)
      - name: Update Cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Deploy to ECS
        run: |
          # Circuit Breaker ì ìš©: ì‹¤íŒ¨ ì‹œ ìë™ ë¡¤ë°±
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_FRONTEND_SERVICE }} --force-new-deployment --deployment-configuration "deploymentCircuitBreaker={enable=true,rollback=true}" --region ${{ env.AWS_REGION }}
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_BACKEND_SERVICE }} --force-new-deployment --deployment-configuration "deploymentCircuitBreaker={enable=true,rollback=true}" --region ${{ env.AWS_REGION }}

      - name: Wait for stability
        run: |
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_FRONTEND_SERVICE }} ${{ env.ECS_BACKEND_SERVICE }} --region ${{ env.AWS_REGION }}

      - name: Collect failure diagnostics
        if: failure()
        id: diagnostics
        run: |
          echo "ğŸ” Collecting diagnostics..."

          # Frontend ì¤‘ì§€ ì›ì¸ íŒŒì•…
          TASK_ARN=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_FRONTEND_SERVICE }} --desired-status STOPPED --max-results 1 --query 'taskArns[0]' --output text)
          if [ "$TASK_ARN" != "None" ] && [ ! -z "$TASK_ARN" ]; then
            REASON=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $TASK_ARN --query 'tasks[0].stoppedReason' --output text)
            echo "frontend_stop_reason=$REASON" >> $GITHUB_OUTPUT
          else
            echo "frontend_stop_reason=Unknown (No stopped task found)" >> $GITHUB_OUTPUT
          fi

          # Backend ì¤‘ì§€ ì›ì¸ íŒŒì•…
          TASK_ARN=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_BACKEND_SERVICE }} --desired-status STOPPED --max-results 1 --query 'taskArns[0]' --output text)
          if [ "$TASK_ARN" != "None" ] && [ ! -z "$TASK_ARN" ]; then
            REASON=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $TASK_ARN --query 'tasks[0].stoppedReason' --output text)
            echo "backend_stop_reason=$REASON" >> $GITHUB_OUTPUT
          else
            echo "backend_stop_reason=Unknown (No stopped task found)" >> $GITHUB_OUTPUT
          fi

          # ë¡œê·¸ ìˆ˜ì§‘ (ìµœê·¼ 50ì¤„)
          aws logs tail ${{ env.CLOUDWATCH_FRONTEND_LOG_GROUP }} --since 10m --format short | tail -50 > /tmp/frontend_logs.txt || echo "No logs" > /tmp/frontend_logs.txt
          aws logs tail ${{ env.CLOUDWATCH_BACKEND_LOG_GROUP }} --since 10m --format short | tail -50 > /tmp/backend_logs.txt || echo "No logs" > /tmp/backend_logs.txt

      - name: Summarize logs with Bedrock
        if: failure()
        id: bedrock-summary
        run: |
          # í”„ë¡¬í”„íŠ¸ ë‚´ìš©ì„ íŒŒì¼ë¡œ ì‘ì„± (ë”°ì˜´í‘œ ì¶©ëŒ ë°©ì§€)
          cat <<EOF > /tmp/prompt.txt
          You are a DevOps engineer analyzing deployment failure logs. Summarize the root cause in Korean.

          [Context]
          Code Changes:
          $(cat /tmp/code_changes.diff | head -c 2000)

          Frontend Logs:
          $(cat /tmp/frontend_logs.txt)

          Backend Logs:
          $(cat /tmp/backend_logs.txt)
          EOF

          # jqë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ˆì „í•œ JSON í˜ì´ë¡œë“œ ìƒì„± (ì´ìŠ¤ì¼€ì´í”„ ì²˜ë¦¬ ìë™í™”)
          jq -n --rawfile prompt /tmp/prompt.txt \
            '{anthropic_version: "bedrock-2023-05-31", max_tokens: 2000, messages: [{role: "user", content: $prompt}]}' > /tmp/payload.json

          # Bedrock í˜¸ì¶œ
          aws bedrock-runtime invoke-model \
            --model-id anthropic.claude-3-sonnet-20240229-v1:0 \
            --body file:///tmp/payload.json \
            --region ${{ env.AWS_REGION }} \
            /tmp/bedrock_response.json
            
          # ì‘ë‹µ ì¶”ì¶œ
          jq -r '.content[0].text' /tmp/bedrock_response.json > /tmp/bedrock_summary.txt

      - name: Create deployment failure issue
        if: failure()
        uses: actions/github-script@v7
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        with:
          script: |
            const fs = require('fs');
            const date = new Date().toISOString().split('T')[0];
            const commit = '${{ github.sha }}'.substring(0, 7);
            const region = process.env.AWS_REGION;

            let summary = "Bedrock analysis failed.";
            try {
              summary = fs.readFileSync('/tmp/bedrock_summary.txt', 'utf8');
            } catch (e) {
              console.log("No bedrock summary found");
            }

            const feReason = '${{ steps.diagnostics.outputs.frontend_stop_reason }}';
            const beReason = '${{ steps.diagnostics.outputs.backend_stop_reason }}';

            // AWS ì½˜ì†” ë§í¬ ë™ì  ìƒì„± (ë¦¬ì „ ë°˜ì˜)
            const logLink = `https://${region}.console.aws.amazon.com/cloudwatch/home?region=${region}#logsV2:log-groups`;

            const body = `## ğŸš¨ ë°°í¬ ì‹¤íŒ¨ (${date})

            **Commit:** ${commit}
            **Branch:** ${{ github.ref_name }}

            ### ğŸ¤– AI ë¶„ì„ ê²°ê³¼
            ${summary}

            ---
            ### ğŸ” ìƒì„¸ ì§„ë‹¨
            - **Frontend ì¤‘ì§€ ì‚¬ìœ :** ${feReason}
            - **Backend ì¤‘ì§€ ì‚¬ìœ :** ${beReason}

            [CloudWatch ë¡œê·¸ í™•ì¸í•˜ê¸°](${logLink})
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ ë°°í¬ ì‹¤íŒ¨ - ${date} (${commit})`,
              body: body,
              labels: ['deployment', 'failure', 'automated']
            });

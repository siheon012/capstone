name: Deploy to Production

on:
  push:
    branches: [develop, feature/*]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  security-events: write

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_FRONTEND_REPO: ${{ secrets.ECR_FRONTEND_REPO }}
  ECR_BACKEND_REPO: ${{ secrets.ECR_BACKEND_REPO }}
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
  ECS_FRONTEND_SERVICE: ${{ secrets.ECS_FRONTEND_SERVICE }}
  ECS_BACKEND_SERVICE: ${{ secrets.ECS_BACKEND_SERVICE }}
  CLOUDWATCH_FRONTEND_LOG_GROUP: /ecs/${{ secrets.ECR_FRONTEND_REPO }}
  CLOUDWATCH_BACKEND_LOG_GROUP: /ecs/${{ secrets.ECR_BACKEND_REPO }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      # 1. AWS ìê²© ì¦ëª… ì„¤ì • (ë§¨ ìœ„ë¡œ ë°°ì¹˜)
      # Trivyê°€ ì‹¤íŒ¨í•˜ë”ë¼ë„ ì´í›„ ë‹¨ê³„(Bedrock, Log ìˆ˜ì§‘)ì—ì„œ AWS CLIë¥¼ ì¨ì•¼ í•˜ë¯€ë¡œ í•„ìˆ˜ì…ë‹ˆë‹¤.
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Collect code changes
        id: git-diff
        run: |
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            git diff HEAD~1 HEAD > /tmp/code_changes.diff
            echo "has_diff=true" >> $GITHUB_OUTPUT
          else
            echo "No previous commit" > /tmp/code_changes.diff
            echo "has_diff=false" >> $GITHUB_OUTPUT
          fi

      # 2. ë³´ì•ˆ ì·¨ì•½ì  ìŠ¤ìº” (Frontend)
      - name: Security Scan - Frontend (Trivy)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './front'
          ignore-unfixed: true
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

      # 3. ë³´ì•ˆ ì·¨ì•½ì  ìŠ¤ìº” (Backend)
      - name: Security Scan - Backend (Trivy)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './back'
          ignore-unfixed: true
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build and push Frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build --target production \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest \
            --push ./front

      - name: Build and push Backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest \
            --push ./back

      - name: Update Cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Deploy to ECS
        run: |
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_FRONTEND_SERVICE }} --force-new-deployment --deployment-configuration "deploymentCircuitBreaker={enable=true,rollback=true}" --region ${{ env.AWS_REGION }}
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_BACKEND_SERVICE }} --force-new-deployment --deployment-configuration "deploymentCircuitBreaker={enable=true,rollback=true}" --region ${{ env.AWS_REGION }}

      - name: Wait for stability
        run: |
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_FRONTEND_SERVICE }} ${{ env.ECS_BACKEND_SERVICE }} --region ${{ env.AWS_REGION }}

      # --- ì‹¤íŒ¨ ì‹œ ì§„ë‹¨ ë° ë¦¬í¬íŒ… (DevOps í•µì‹¬) ---

      - name: Collect failure diagnostics
        if: failure()
        id: diagnostics
        run: |
          echo "ğŸ” Collecting diagnostics..."

          # íŒŒì¼ ìƒì„± (ì—†ìœ¼ë©´ ìƒì„±í•´ì„œ ì—ëŸ¬ ë°©ì§€)
          touch /tmp/frontend_logs.txt
          touch /tmp/backend_logs.txt

          # Frontend ì¤‘ì§€ ì›ì¸
          TASK_ARN=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_FRONTEND_SERVICE }} --desired-status STOPPED --max-results 1 --query 'taskArns[0]' --output text)
          if [ "$TASK_ARN" != "None" ] && [ ! -z "$TASK_ARN" ]; then
            REASON=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $TASK_ARN --query 'tasks[0].stoppedReason' --output text)
            echo "frontend_stop_reason=$REASON" >> $GITHUB_OUTPUT
          else
            echo "frontend_stop_reason=Unknown (No stopped task found)" >> $GITHUB_OUTPUT
          fi

          # Backend ì¤‘ì§€ ì›ì¸
          TASK_ARN=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_BACKEND_SERVICE }} --desired-status STOPPED --max-results 1 --query 'taskArns[0]' --output text)
          if [ "$TASK_ARN" != "None" ] && [ ! -z "$TASK_ARN" ]; then
            REASON=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $TASK_ARN --query 'tasks[0].stoppedReason' --output text)
            echo "backend_stop_reason=$REASON" >> $GITHUB_OUTPUT
          else
            echo "backend_stop_reason=Unknown (No stopped task found)" >> $GITHUB_OUTPUT
          fi

          # ë¡œê·¸ ìˆ˜ì§‘
          aws logs tail ${{ env.CLOUDWATCH_FRONTEND_LOG_GROUP }} --since 10m --format short | tail -50 > /tmp/frontend_logs.txt || echo "No logs" > /tmp/frontend_logs.txt
          aws logs tail ${{ env.CLOUDWATCH_BACKEND_LOG_GROUP }} --since 10m --format short | tail -50 > /tmp/backend_logs.txt || echo "No logs" > /tmp/backend_logs.txt

      # ğŸ› ï¸ [í•µì‹¬ ìˆ˜ì •] Python + Boto3ë¥¼ ì‚¬ìš©í•˜ì—¬ í•œê¸€/íŠ¹ìˆ˜ë¬¸ì ì¸ì½”ë”© ì—ëŸ¬ ì™„ë²½ í•´ê²°
      - name: Summarize logs with Bedrock
        if: failure()
        id: bedrock-summary
        run: |
          # 1. AWS SDK ì„¤ì¹˜ (boto3)
          pip install boto3

          # 2. Python ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
          python3 -c "
          import json
          import os
          import boto3

          def read_file_safe(path):
              try:
                  if os.path.exists(path):
                      # errors='replace'ë¡œ ì¸ì½”ë”© ì—ëŸ¬ ë°©ì§€
                      with open(path, 'r', encoding='utf-8', errors='replace') as f:
                          return f.read()[:5000] # ë„ˆë¬´ ê¸¸ë©´ 5000ìì—ì„œ ìë¦„
              except Exception as e:
                  return f'Error reading file: {str(e)}'
              return 'No data'

          # íŒŒì¼ ì½ê¸°
          code_changes = read_file_safe('/tmp/code_changes.diff')
          front_logs = read_file_safe('/tmp/frontend_logs.txt')
          back_logs = read_file_safe('/tmp/backend_logs.txt')

          # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
          prompt = f'''You are a DevOps engineer analyzing deployment failure logs. 
          Summarize the root cause in Korean. Focus on the error logs provided.

          [Code Changes]
          {code_changes}

          [Frontend Logs]
          {front_logs}

          [Backend Logs]
          {back_logs}
          '''

          # Bedrock í˜¸ì¶œì„ ìœ„í•œ JSON í˜ì´ë¡œë“œ ìƒì„±
          payload = {
              'anthropic_version': 'bedrock-2023-05-31',
              'max_tokens': 2000,
              'messages': [{'role': 'user', 'content': prompt}]
          }

          # AWS Bedrock í˜¸ì¶œ
          try:
              client = boto3.client('bedrock-runtime', region_name='${{ env.AWS_REGION }}')
              response = client.invoke_model(
                  modelId='anthropic.claude-3-5-sonnet-20241022-v2:0',
                  body=json.dumps(payload, ensure_ascii=False)
              )
              
              # ê²°ê³¼ íŒŒì‹± ë° ì €ì¥
              result = json.loads(response['body'].read())
              summary = result['content'][0]['text']
              
              with open('/tmp/bedrock_summary.txt', 'w', encoding='utf-8') as f:
                  f.write(summary)
              print('âœ… Bedrock analysis complete.')
              
          except Exception as e:
              print(f'âŒ Bedrock failed: {str(e)}')
              with open('/tmp/bedrock_summary.txt', 'w', encoding='utf-8') as f:
                  f.write(f'AI ë¶„ì„ ì‹¤íŒ¨ (System Error): {str(e)}')
          "

      - name: Create deployment failure issue
        if: failure()
        uses: actions/github-script@v7
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        with:
          script: |
            const fs = require('fs');
            const date = new Date().toISOString().split('T')[0];
            const commit = '${{ github.sha }}'.substring(0, 7);
            const region = process.env.AWS_REGION;

            let summary = "Bedrock analysis failed.";
            try {
              summary = fs.readFileSync('/tmp/bedrock_summary.txt', 'utf8');
            } catch (e) {
              console.log("No bedrock summary found");
            }

            const feReason = '${{ steps.diagnostics.outputs.frontend_stop_reason }}';
            const beReason = '${{ steps.diagnostics.outputs.backend_stop_reason }}';

            const safeFeReason = feReason || "Not checked";
            const safeBeReason = beReason || "Not checked";

            const logLink = `https://${region}.console.aws.amazon.com/cloudwatch/home?region=${region}#logsV2:log-groups`;

            const body = `## ğŸš¨ ë°°í¬ ì‹¤íŒ¨ (ë³´ì•ˆ ì·¨ì•½ì  ë°œê²¬ ë“±) - ${date}

            **Commit:** ${commit}
            **Branch:** ${{ github.ref_name }}

            ### ğŸ¤– AI ë¶„ì„ ê²°ê³¼
            ${summary}

            ---
            ### ğŸ” ìƒì„¸ ì§„ë‹¨
            - **Frontend ì¤‘ì§€ ì‚¬ìœ :** ${safeFeReason}
            - **Backend ì¤‘ì§€ ì‚¬ìœ :** ${safeBeReason}

            [CloudWatch ë¡œê·¸ í™•ì¸í•˜ê¸°](${logLink})
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ ë°°í¬ ì‹¤íŒ¨ - ${date} (${commit})`,
              body: body,
              labels: ['deployment', 'failure', 'automated']
            });

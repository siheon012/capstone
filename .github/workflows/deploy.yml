name: Deploy to Production

# â›” DISABLED - terraform destroy ì¤€ë¹„ ì¤‘
on: []
# on:
#   push:
#     branches: [main]
#   workflow_dispatch:

permissions:
  contents: read
  issues: write
  security-events: write

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_FRONTEND_REPO: ${{ secrets.ECR_FRONTEND_REPO }}
  ECR_BACKEND_REPO: ${{ secrets.ECR_BACKEND_REPO }}
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
  ECS_FRONTEND_SERVICE: ${{ secrets.ECS_FRONTEND_SERVICE }}
  ECS_BACKEND_SERVICE: ${{ secrets.ECS_BACKEND_SERVICE }}
  CLOUDWATCH_FRONTEND_LOG_GROUP: /ecs/${{ secrets.ECR_FRONTEND_REPO }}
  CLOUDWATCH_BACKEND_LOG_GROUP: /ecs/${{ secrets.ECR_BACKEND_REPO }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Collect code changes
        id: git-diff
        run: |
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            git diff HEAD~1 HEAD > /tmp/code_changes.diff
            echo "has_diff=true" >> $GITHUB_OUTPUT
          else
            echo "No previous commit" > /tmp/code_changes.diff
            echo "has_diff=false" >> $GITHUB_OUTPUT
          fi

      # ğŸ›¡ï¸ Trivy Frontend Scan (íŒŒì¼ë¡œ ê²°ê³¼ ì €ì¥)
      - name: Security Scan - Frontend (Trivy)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './front'
          ignore-unfixed: true
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
          output: 'trivy_front.txt'

      # Trivy ê²°ê³¼ ì²˜ë¦¬ (ì‹¤íŒ¨í•´ë„ ë¡œê·¸ í™•ë³´)
      - name: Check Trivy Frontend Result
        if: always()
        run: |
          if [ -f trivy_front.txt ]; then
            cat trivy_front.txt
            mv trivy_front.txt /tmp/trivy_front_log.txt
          else
            echo "No Trivy logs" > /tmp/trivy_front_log.txt
          fi

      # ğŸ›¡ï¸ Trivy Backend Scan
      - name: Security Scan - Backend (Trivy)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './back'
          ignore-unfixed: true
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
          output: 'trivy_back.txt'

      - name: Check Trivy Backend Result
        if: always()
        run: |
          if [ -f trivy_back.txt ]; then
            cat trivy_back.txt
            mv trivy_back.txt /tmp/trivy_back_log.txt
          else
             echo "No Trivy logs" > /tmp/trivy_back_log.txt
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # ğŸ³ Frontend ë¹Œë“œ (ë¡œê·¸ ìº¡ì²˜ ì¶”ê°€)
      - name: Build and push Frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build --target production \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest \
            --push ./front > /tmp/front_build.log 2>&1 || (cat /tmp/front_build.log && exit 1)

      # ğŸ³ Backend ë¹Œë“œ (ë¡œê·¸ ìº¡ì²˜ ì¶”ê°€)
      - name: Build and push Backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker buildx build \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest \
            --push ./back > /tmp/back_build.log 2>&1 || (cat /tmp/back_build.log && exit 1)

      - name: Update Cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Deploy to ECS
        run: |
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_FRONTEND_SERVICE }} --force-new-deployment --deployment-configuration "deploymentCircuitBreaker={enable=true,rollback=true}" --region ${{ env.AWS_REGION }}
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_BACKEND_SERVICE }} --force-new-deployment --deployment-configuration "deploymentCircuitBreaker={enable=true,rollback=true}" --region ${{ env.AWS_REGION }}

      - name: Wait for stability
        run: |
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_FRONTEND_SERVICE }} ${{ env.ECS_BACKEND_SERVICE }} --region ${{ env.AWS_REGION }}

      # --- ì‹¤íŒ¨ ì‹œ ì§„ë‹¨ ë° ë¦¬í¬íŒ… ---

      - name: Collect failure diagnostics
        if: failure()
        id: diagnostics
        run: |
          echo "ğŸ” Collecting diagnostics..."
          touch /tmp/frontend_cw_logs.txt
          touch /tmp/backend_cw_logs.txt

          # CloudWatch ë¡œê·¸ ìˆ˜ì§‘ (ì‹¤í–‰ ë¡œê·¸)
          aws logs tail ${{ env.CLOUDWATCH_FRONTEND_LOG_GROUP }} --since 10m --format short | tail -50 > /tmp/frontend_cw_logs.txt || echo "No CW logs" > /tmp/frontend_cw_logs.txt
          aws logs tail ${{ env.CLOUDWATCH_BACKEND_LOG_GROUP }} --since 10m --format short | tail -50 > /tmp/backend_cw_logs.txt || echo "No CW logs" > /tmp/backend_cw_logs.txt

      # ğŸ› ï¸ [ìµœì¢…] ë¹Œë“œ ë¡œê·¸ + ë³´ì•ˆ ë¡œê·¸ + ì‹¤í–‰ ë¡œê·¸ ëª¨ë‘ ë¶„ì„
      - name: Summarize logs with Bedrock
        if: failure()
        id: bedrock-summary
        run: |
          pip install boto3

          python3 -c "
          import json
          import os
          import boto3

          def read_file_safe(path):
              try:
                  if os.path.exists(path):
                      with open(path, 'r', encoding='utf-8', errors='replace') as f:
                          return f.read()[:5000] # ë„ˆë¬´ ê¸¸ë©´ 5000ì ìë¦„
              except Exception as e:
                  return f'Error reading file: {str(e)}'
              return 'No log found'

          # 1. GitHub Actions Build Logs (ë¹Œë“œ ì—ëŸ¬)
          front_build_log = read_file_safe('/tmp/front_build.log')
          back_build_log = read_file_safe('/tmp/back_build.log')

          # 2. Trivy Security Logs (ë³´ì•ˆ ì—ëŸ¬)
          trivy_front = read_file_safe('/tmp/trivy_front_log.txt')
          trivy_back = read_file_safe('/tmp/trivy_back_log.txt')

          # 3. CloudWatch Logs (ëŸ°íƒ€ì„ ì—ëŸ¬)
          front_cw = read_file_safe('/tmp/frontend_cw_logs.txt')
          back_cw = read_file_safe('/tmp/backend_cw_logs.txt')

          code_changes = read_file_safe('/tmp/code_changes.diff')

          prompt = f'''You are a DevOps expert. Analyze the failure.
          Use Korean.

          [Code Changes]
          {code_changes}

          [Build Logs (Docker/Build Error)]
          Frontend Build: {front_build_log}
          Backend Build: {back_build_log}

          [Security Scan Logs (Trivy)]
          Frontend Security: {trivy_front}
          Backend Security: {trivy_back}

          [Runtime Logs (CloudWatch)]
          Frontend Runtime: {front_cw}
          Backend Runtime: {back_cw}

          Summarize the root cause based on the logs above.
          '''

          payload = {
              'anthropic_version': 'bedrock-2023-05-31',
              'max_tokens': 2000,
              'messages': [{'role': 'user', 'content': prompt}]
          }

          try:
              # ì„œìš¸ ë¦¬ì „ Haiku ì‚¬ìš©
              client = boto3.client('bedrock-runtime', region_name='${{ env.AWS_REGION }}')
              response = client.invoke_model(
                  modelId='anthropic.claude-3-haiku-20240307-v1:0',
                  body=json.dumps(payload, ensure_ascii=False)
              )
              
              result = json.loads(response['body'].read())
              summary = result['content'][0]['text']
              
              with open('/tmp/bedrock_summary.txt', 'w', encoding='utf-8') as f:
                  f.write(summary)
              print('âœ… Bedrock analysis complete.')
              
          except Exception as e:
              print(f'âŒ Bedrock failed: {str(e)}')
              with open('/tmp/bedrock_summary.txt', 'w', encoding='utf-8') as f:
                  f.write(f'AI Analysis Failed: {str(e)}')
          "

      - name: Create deployment failure issue
        if: failure()
        uses: actions/github-script@v7
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
        with:
          script: |
            const fs = require('fs');
            const date = new Date().toISOString().split('T')[0];
            const commit = '${{ github.sha }}'.substring(0, 7);
            const region = process.env.AWS_REGION;

            let summary = "Bedrock analysis failed.";
            try {
              summary = fs.readFileSync('/tmp/bedrock_summary.txt', 'utf8');
            } catch (e) {
              console.log("No bedrock summary found");
            }

            const body = `## ğŸš¨ ë°°í¬ ì‹¤íŒ¨ ë¦¬í¬íŠ¸ - ${date}

            **Commit:** ${commit}
            **Branch:** ${{ github.ref_name }}

            ### ğŸ¤– AI ë¶„ì„ ê²°ê³¼ (Build & Security & Runtime)
            ${summary}

            ---
            **ì°¸ê³ :** ë¹Œë“œ/ë³´ì•ˆ ë‹¨ê³„ì—ì„œ ì‹¤íŒ¨í•œ ê²½ìš° ECS ë¡œê·¸ëŠ” ì—†ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ ë°°í¬ ì‹¤íŒ¨ - ${date} (${commit})`,
              body: body,
              labels: ['deployment', 'failure', 'automated']
            });

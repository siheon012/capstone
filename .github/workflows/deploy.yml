name: Deploy to Production

on:
  push:
    branches: [ECSFargate]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_FRONTEND_REPO: ${{ secrets.ECR_FRONTEND_REPO }}
  ECR_BACKEND_REPO: ${{ secrets.ECR_BACKEND_REPO }}
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
  ECS_FRONTEND_SERVICE: ${{ secrets.ECS_FRONTEND_SERVICE }}
  ECS_BACKEND_SERVICE: ${{ secrets.ECS_BACKEND_SERVICE }}
  CLOUDWATCH_FRONTEND_LOG_GROUP: /ecs/${{ secrets.ECR_FRONTEND_REPO }}
  CLOUDWATCH_BACKEND_LOG_GROUP: /ecs/${{ secrets.ECR_BACKEND_REPO }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Collect code changes
        id: git-diff
        run: |
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            git diff HEAD~1 HEAD > /tmp/code_changes.diff
            echo "has_diff=true" >> $GITHUB_OUTPUT
          else
            echo "No previous commit" > /tmp/code_changes.diff
            echo "has_diff=false" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build and push images
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # 빌드 및 푸시를 통합하여 효율화 가능 (예시는 유지)
          docker buildx build --target production \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest \
            --push ./front

          docker buildx build \
            --cache-from=type=local,src=/tmp/.buildx-cache \
            --cache-to=type=local,dest=/tmp/.buildx-cache-new,mode=max \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG \
            -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest \
            --push ./back

          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Deploy to ECS
        run: |
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_FRONTEND_SERVICE }} --force-new-deployment --deployment-configuration "deploymentCircuitBreaker={enable=true,rollback=true}"
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_BACKEND_SERVICE }} --force-new-deployment --deployment-configuration "deploymentCircuitBreaker={enable=true,rollback=true}"

      - name: Wait for stability
        run: |
          aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_FRONTEND_SERVICE }} ${{ env.ECS_BACKEND_SERVICE }}

      - name: Collect failure diagnostics
        if: failure()
        id: diagnostics
        run: |
          # 최근 중지된 태스크 원인 및 로그 수집 (기존 로직 유지하되 에러 방어 추가)
          FRONTEND_REASON=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_FRONTEND_SERVICE }} --desired-status STOPPED --query 'taskArns[0]' --output text) --query 'tasks[0].stoppedReason' --output text 2>/dev/null || echo "Unknown")
          BACKEND_REASON=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_BACKEND_SERVICE }} --desired-status STOPPED --query 'taskArns[0]' --output text) --query 'tasks[0].stoppedReason' --output text 2>/dev/null || echo "Unknown")

          echo "frontend_stop_reason=$FRONTEND_REASON" >> $GITHUB_OUTPUT
          echo "backend_stop_reason=$BACKEND_REASON" >> $GITHUB_OUTPUT

          aws logs tail ${{ env.CLOUDWATCH_FRONTEND_LOG_GROUP }} --since 10m --format short | tail -50 > /tmp/frontend_logs.txt || true
          aws logs tail ${{ env.CLOUDWATCH_BACKEND_LOG_GROUP }} --since 10m --format short | tail -50 > /tmp/backend_logs.txt || true

      - name: Summarize logs with Bedrock
        if: failure()
        id: bedrock-summary
        run: |
          # 안전한 JSON 생성을 위해 jq 사용
          PROMPT_TEXT=$(cat <<EOF
          You are a DevOps engineer analyzing deployment failure logs. Summarize the root cause in Korean.

          [Context]
          Code Changes: $(cat /tmp/code_changes.diff | head -c 2000)

          Frontend Logs: $(cat /tmp/frontend_logs.txt)
          Backend Logs: $(cat /tmp/backend_logs.txt)
          EOF
          )

          # JSON 바디 구성 (이스케이프 처리)
          BODY=$(jq -n --arg msg "$PROMPT_TEXT" '{anthropic_version: "bedrock-2023-05-31", max_tokens: 2000, messages: [{role: "user", content: $msg}]}')

          aws bedrock-runtime invoke-model \
            --model-id anthropic.claude-3-sonnet-20240229-v1:0 \
            --body "$BODY" \
            --region ${{ env.AWS_REGION }} \
            /tmp/bedrock_response.json
            
          jq -r '.content[0].text' /tmp/bedrock_response.json > /tmp/bedrock_summary.txt
